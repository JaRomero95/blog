[ { "title": "Single line methods add value", "url": "/posts/single-line-methods-add-value/", "categories": "Backend, Frontend", "tags": "clean code", "date": "2021-11-08 18:00:00 +0100", "snippet": "IntroductionSometimes people may complain about how unnecessary some methods are. They say there is no need to create a new method if it is made up of a single line of code, that leaving the code in a higher-order place is enough because it is easy to understand. But I can’t agree with that.A good enough codeLet’s see an example. Imagine that we are creating a service to export a file with users and we have something like this:class UsersExporter # more code def export users = find_users_to_export file = File.new &quot;files/users_#{Time.new.to_i}.csv&quot;, &#39;w&#39; write_users(file, users) end # more codeendThink about the line where we are creating the destination file. It’s easy to read and any developer can read and understand that sentence in the blink of an eye. We might think that our code is good enough.Hiding detailsBut let’s put this example aside for a moment. Some years ago, Uncle Bob wrote one of the most acclaimed books on software development, “Clean Code: A Handbook of Agile Software Craftsmanship”.One of the quotes that he left us in this book was the following: So if you want to go fast, if you want to get done quickly, if you want your code to be easy to write, make it easy to read.As he explains, one thing we need to do is hide the implementation details in our code. We want readers to be able to know what our code does without having to stop to read it and understand everything.Following The Stepdown Rule that he talks about, we want to keep our main methods as abstract as possible. It’s not about really hiding the implementation details so that no one can figure out how our program works, but only needing to understand the low-level details when necessary.Improving the codeSo, go back to our example and look carefully at the suspicious line:file = File.new &quot;files/users_#{Time.new.to_i}.csv&quot;, &#39;w&#39;How many things can we know when we read this line? Use the File class. Create the file using the w flag to write on it. The file has the extension csv. Use the current time on Unix to form the file name. Save the file in the local file system.All of this is in one little sentence. A ruby programmer probably knows enough about the File and Time classes to understand the entire sentence without asking for the w flag or the to_i method.But what is sure is that it doesn’t want to know all these things at this point. Maybe it just wants to add a user field to the result or change the query to filter users.The reader doesn’t care what class you are using to create the file. Or where you are saving it, nor the name of the file. Are you using the File class or a wrapper to handle files? Are you saving the file to the local system or in a document-based database? It does not care.When it needs to know about the file, it can go to the implementation details and read carefully how it is created and where it is placed. In the meantime, we don’t want to fill its head with trivial details.class UsersExporter # more code def export users = find_users_to_export file = create_destination_file write_users(file, users) end # moreendNow the reader can know what the code does by reading just three simple sentences and can choose what to read next.A different exampleIt’s not only a backend thing, we can apply this recommendation to any other language or framework.Let’s look at a quick example of a useful single-line method in Vue:export default { // more stuff... async created() { this.users = await UsersService.index(this.params); }}Would it seem silly to create a single-line method that wraps the content of the created method? Maybe… But what if we need to get the users after a different event? Do we want to duplicate the method?export default { // more stuff... async created() { this.users = await UsersService.index(this.params); } methods() { onFilter() { this.users = await UsersService.index(this.params); } }}If we extract the method, we are improving our code. The top-level method is more abstract: the reader knows that we are getting the users when the component is created, but it does not know how and it does not care at this point. And, we are reusing code: if we need to change the UsersService.index signature, we need to modify only one line, not two or more calls in each file.export default { // more stuff... async created() { this.getUsers(); } methods() { onFilter() { this.getUsers(); }, getUsers() { this.users = await UsersService.index(this.params); } }}ConclusionThat is all. These might seem like minor details, but this care about minor details is what keeps our code clean and prevent us from losing control of it. Keep your readers focused on what matters at the moment. I hope you have enjoyed it!" }, { "title": "Avoid Vue.set - Reactivity and immutability", "url": "/posts/avoid-vue-set/", "categories": "Frontend", "tags": "javascript, vue, immutability", "date": "2020-01-16 18:00:00 +0100", "snippet": "IntroductionVue uses reactivity to listen for changes in component data and update the view if necessary after a change.To achieve this, Vue adds getters and setters that wrap each property that we define. When we modify a value, we are calling the setter method that was created earlier. Through this setter, Vue can notice the change.However, there are some situations where we find that our component does not update after a value changes.Reactivity problemsLet’s look at the following component:export default { data: () =&amp;gt; ({ post: { title: &#39;The Last Wish&#39; } }), methods: { toggleFav() { this.post.fav = !this.post.fav; } }}And its template:&amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; &amp;lt;span v-if=&quot;post.fav&quot;&amp;gt;♥&amp;lt;/span&amp;gt; Hello! &amp;lt;/h1&amp;gt; &amp;lt;button @click=&quot;toggleFav&quot;&amp;gt;Fav&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;If we run this example and try to use the button, we’ll see that the page does not change. However, if we debug the component with the browser development tools, we’ll see that the fav value changes even if the view does not reflect it.We commented before that Vue adds getters and setters to the properties we defined in our component. The fav field, as we didn’t declare it within the post model in the data of our component and we add it later, it has not been initialized correctly so it does not have these methods and Vue does not detect any change when we modify it.Fixing this problem would be as easy as setting an initial value for the fav field:// ...data: () =&amp;gt; ({ post: { title: &#39;The Last Wish&#39;, fav: false }})// ...There are some situations where Vue cannot detect changes: New properties added to an existing object Properties removed from an object Set an element to a specific position in an array Changes in the length of an array To avoid problems with common situations such as mutations in arrays, Vue transparently overwrites some of its methods, since otherwise, it would not be able to detect the mutations made when we invoke them. The methods Vue modify so that you can use them without worrying about reactivity are: push, pop, shift, unshift, splice, sort and reverse. But I recommend you don’t use them too, for the same reasons I explained in this article.Vue.setProbably you already knew about reactivity in Vue and these specific cases, but I wanted to reintroduce them to talk about one of the proposed solutions for this problem, which is the set method of Vue.Here are some examples:// Vue.set(object, propertyName, value)Vue.set(this.post, &#39;fav&#39;, !this.post.fav);this.$set(this.post, &#39;fav&#39;, !this.post.fav);this.$set(this.posts, 1, post);Vue.set simply ensures that the new value is set as a reactive property, solving the problem of not having declared it initially.Is a quick and easy solution, but in my opinion, we should avoid this method.Why avoid Vue.setReactivity problems in Vue usually stem from a poorly designed component and come to light when we try to mutate an object. Using a brute force method like this prevents us from doing the right thing: refactoring.Our components should be as small as possible, because the easier it is to extract the component code to another place, the easier it will be to add or modify functions. Otherwise, this method couples the code to the Vue API, forcing us to change the code before we can move to a non-component file.Finally, avoiding using this method forces us to know more about immutability and its benefits in JavaScript, knowledge that will help us write pure and reusable functions and avoid having to face a tough debugging process due to unexpected mutations.Vue.set alternativesIf we are faced with one of the cases listed above, in which Vue cannot detect changes in our components, we have different options depending on the situation.New properties added to an existing objectIn this case, we’ll choose to create a new object containing all previous properties plus the one we are adding. Then we can change the reference to our new object. Vue will easily detect the change and update the view based on the new value.For this, we have two options. First, using Object.assign:toggleFav() { this.post = Object.assign({}, this.post, {fav: !this.post.fav});}And second, the one I prefer, using spread syntax:toggleFav() { this.post = {...this.post, fav: !this.post.fav};}Properties removed from an objectIf what you want is not to add, but remove a property of an object, we can also do it without mutating it. We have several options, one of these will be to clone the object, delete the property and, as in the previous example, replace the object.deleteFavProperty() { const post = {...this.post}; delete post.fav; this.post = post;} Be careful with objects that contain another object in some of their properties, because if you clone them in this way, child objects won’t be cloned and you could unintentionally mutate them. Use another method of cloning or avoid working with complex objects if you can.We have another alternative. Here we can make use of rest/spread, which again is the one I prefer.deleteFavProperty() { const {fav, ...rest} = this.post; this.post = rest;}Set an element to a specific position in an arrayIf we try to do the following:replacePost(index, newPost) { this.posts[index] = newPost;}We’ll see that Vue does not detect it either. The simplest option to avoid using Vue.set would be the Array.splice. Let’s see how it looks:replacePost(index, newPost) { this.posts.splice(index, 1, newPost);}But yes, this method mutates the array. We mentioned earlier that Vue replaces some Array methods to be able to detect changes, and this is one of them.However, we prefer to avoid mutations because some higher or lower components in our composition could be using this data. So we can apply one of the following options:replacePost(index, newPost) { // A this.posts = this.posts.map((post, postIndex) =&amp;gt; { return postIndex === index ? newPost : post; }); // B this.posts = Object.assign([], this.posts, {[index]: newPost}); // C this.posts = [ ...this.posts.slice(0, index), newPost, ...this.posts.slice(index + 1), ]}Changes in the length of an arrayFinally, we have the least common case, the modification of the length of an array:incrementPostsLength(numberOfEmptySpaces) { this.posts.length += numberOfEmptySpaces;}If we test this case, we’ll see that Vue does not detect it. There are a few options to do this. One of them will be to create a new array with the number of elements that we want to add and concatenate it at the end of the original, giving rise to a new one:incrementPostsLength(numberOfEmptySpaces) { const emptySpaces = new Array(numberOfEmptySpaces); this.posts = [...this.posts, ...emptySpaces];}ConclusionI prefer to take advantage of the options the language offers than use the Vue API or any other third-party code when it’s not really necessary, avoiding adding dependencies to my code.Don’t get me wrong, third party libraries are useful, but we don’t have to abuse them. The abuse of “lodash” is a clear example of this.If you choose these options, your code will be more portable and you’ll learn how to take advantage of immutability, a knowledge that you can apply in your next JavaScript development, whatever framework you use." }, { "title": "The tap method in Ruby", "url": "/posts/ruby-tap-method/", "categories": "Backend", "tags": "ruby, clean code", "date": "2019-09-10 19:00:00 +0200", "snippet": "IntroductionRuby’s tap method is as simple as it is effective, although not many use it.This method belongs to the Object class and basically what it does when we invoke it on an instance is send self to the block we pass to it and finally returns the same instance.It’s useful when we need a method to return the instance itself instead of the last operation result, and in this way to be able to concatenate with other similar methods or simply avoid referencing it in an auxiliary variable.How to use itLet’s see an example to understand how it works. We have the following Ruby class:class Hobbit def eat puts &quot;#{name} eats a whole lembas bread.&quot; self.hungry = false end def smoke puts &quot;#{name} takes a break to smoke Longbottom Leaf.&quot; self.stressed = false endendTo test it, we are going to instantiate an object of this class and invoke its methods.hobbit = Hobbit.new(&#39;Pippin&#39;)hobbit.eathobbit.smokeIt’s not bad, but it’ll be better if we could call both methods in a row. We are going to change these methods so they return the instance at the end of each one to be able to do method chaining.class Hobbit def eat puts &quot;#{name} eats a whole lembas bread.&quot; self.hungry = false self end def smoke puts &quot;#{name} takes a break to smoke Longbottom Leaf.&quot; self.stressed = false self endendNow, we can do method chaining:hobbit = Hobbit.new(&#39;Pippin&#39;)hobbit.eat.smokeWe have achieved what we wanted, but returning self explicitly at the end of each method seems a bit forced. This is where the tap method comes to the rescue to make our code better express itself. Let’s change our methods again:class Hobbit def eat tap do |hobbit| puts &quot;#{hobbit.name} eats a whole lembas bread.&quot; hobbit.hungry = false end end def smoke tap do |hobbit| puts &quot;#{hobbit.name} takes a break to smoke Longbottom Leaf.&quot; hobbit.stressed = false end endendNow we keep the ability to do method chaining but with a little more syntax sugar.It’s true that the example is too basic to see the usefulness of this method because it was even shorter in the previous form, also we don’t need to use the variable that the method receives. Let’s look at a more useful example for the real world:class CharacterFactory def create_sample_hobbit character = Humanoid.new character.height = 90 character.weight = 35_000 features = %i[hairy_feet good_aim] character.add_features(features) self endendAnd now we are going to refactor this code using the tap method. Let’s see:class CharacterFactory def create_sample_hobbit Humanoid.new.tap do |character| character.height = 90 character.weight = 35_000 features = %i[hairy_feet good_aim] character.add_features(features) end endendGrouping actions in the tap block is useful for clarifying intentions in our code, so the previous example will give us a slight improvement in readability.ConclusionThat’s all! Personally, I like to use these details that Ruby offers to try to make my code more expressive and easy to read, but these are just little things that can be useful in very specific situations, and at the end of the day, it is up to you to choose a style or other." }, { "title": "Jekyll, a tool for creating blogs focused on developers", "url": "/posts/jekyll/", "categories": "Tools", "tags": "jekyll", "date": "2019-08-24 19:00:00 +0200", "snippet": "IntroductionIf you are a developer and you would like to have your blog, with Jekyll you can create it quickly and maintain full control to customize it.Jekyll allows us to write our posts using markdown, customize our template and add plugins that offer us features like SEO metatags or an automatic sitemap generator among other things.Why use JekyllAlthough exposed like this it looks like another CMS, it has nothing to do with other tools for this purpose that have huge administration panels, databases or complex visual editors for non-developers.This tool uses Ruby to build static files from our template and the content of our posts, so the final result once generated is lightweight and we can upload it to any hosting without worrying about databases or other services.Don’t be scared if you’ve never programmed in Ruby because you don’t need to touch a single line of Ruby code to create the project, write posts or customize the template. You only need to install Ruby to test and visualize the website locally before uploading it.Furthermore, you can comfortably deploy your blog with GitHub Pages, and it’s free. Not only does it have built-in support for this platform, but it is the officially recommended tool by GitHub for this purpose.Key benefitsI’ve already decided to use Jekyll for my blog, and I’ll tell you the reasons that made me choose it: You can write your posts using Markdown. It allows you to change your theme fast. You can get themes here and here. It allows you to create your theme from scratch. You can reuse template parts with no difficulty, like the header or footer of your blog. Easy to deploy regardless of the service you use. You have a lot of plugins developed by the Jekyll community to add features likes metatags, sitemap or RSS. If you need it, you can create your plugins in Ruby to add more features.Get startedYou don’t need much to get started with Jekyll. Install Ruby on your computer and the necessary gems to create the project. With that, you can test your blog before uploading it. Change the site title, description, and write your first posts. Lastly, create a repository on GitHub, upload the project and set up GitHub Pages.If you still find it cumbersome anyway, you have at your disposal Jekyll Now that allows you to create your blog without leaving GitHub.I won’t tell you more because I prefer that you see the complete and updated documentation on his official website.Take a look and start writing!" } ]
